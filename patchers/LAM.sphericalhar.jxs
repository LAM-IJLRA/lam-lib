<jittershader name="sphericalharmonics-glsl">
	<description>Spherical harmonics shader, with phong lighting</description>
	<param name="m1" type="vec4" default="0. 0. 0. 0." />
	<param name="sphere" type="float" default="0.1" />
	<param name="m2" type="vec4" default="0. 0. 0. 0." />
	<param name="fig" type="vec4" default="1. 1. 1. 1." />
	<param name="thresh" type="float" default="0." />
	<param name="delta" type="float" default="0.01" />
	<param name="Ia" type="vec4" default="0. 0. 0. 0.0" />
	<param name="Ii" type="vec4" default="1. 1. 1. 1.0" />
	<param name="eyePosition" type="vec3" default="0. 0. 4."/>
	<param name="Ke" type="vec4" default="0.0 0.0 0.0 0.0" />
	<param name="Ka" type="vec4" default="1.0 1.0 1.0 1.0" />
	<param name="Kd" type="vec4" default="0.3 0.3 0.3 1.0" />
	<param name="Ks" type="vec4" default="1.0 1.0 1.0 1.0" />
	<param name="Ns" type="float" default="10." />
	<param name="couleur" type="vec4" default="1.0 1.0 1.0 1.0" />	
	<language name="glsl" version="1.0">
		<bind param="m1" program="vp" />
		<bind param="sphere" program="vp" />
		<bind param="fig" program="fp" />
		<bind param="thresh" program="fp" />
		<bind param="m2" program="vp" />
		<bind param="delta" program="vp" />
		<bind param="Ia" program="fp" />
		<bind param="Ii" program="fp" />
		<bind param="eyePosition" program="fp" />
		<bind param="Ka" program="fp" />
		<bind param="Kd" program="fp" />
		<bind param="Ks" program="fp" />
		<bind param="Ns" program="fp" />
		<bind param="couleur" program="fp" />
		<program name="vp" type="vertex">
<![CDATA[

varying vec3 N;
varying vec3 P;

//varying vec2 texcoord;

#define PI 3.1415926535

uniform float sphere;
uniform vec4 m1;
uniform vec4 m2;
uniform float delta;

vec3 surface(vec2 point)
{
	
//	texcoord    = vec2(gl_TextureMatrix[0] * gl_MultiTexCoord0);
	    
	float r = 0.;
	r+=sin(m1.x*point.y);
	r+=cos(m1.y*point.y);
	r+=sin(m1.z*point.x);
	r+=cos(m1.w*point.x);

	vec3 s_point;
	float sphi = sin(point.x+m2.x);

	s_point.x = r*sphi*cos(point.y+m2.y);
	s_point.z = r*cos(point.x+m2.z);
	s_point.y = r*sphi*sin(point.y+m2.w);
	
	vec3 o_point;
	sphi = sin(point.x);
	o_point.x = sphi*cos(point.y);
	o_point.z = cos(point.x);
	o_point.y = sphi*sin(point.y);
	s_point = mix(s_point,o_point,sphere);
	return s_point;
}


void main (void)
{
	vec4 V = vec4( surface(gl_Vertex.xy), 1.);

	//get the vertices into eye space
	P = (gl_ModelViewMatrix*V).xyz;
	
	vec3 neighbour1 = surface(vec2(gl_Vertex.x + delta, gl_Vertex.y));
	vec3 neighbour2 = surface(vec2(gl_Vertex.x, gl_Vertex.y + delta));
	
	vec3 tangent = normalize(neighbour1 - V.xyz);
	vec3 bitangent = normalize(neighbour2 - V.xyz);

	//get the normals into eye space
	N = normalize( cross(tangent, bitangent) );
	N = mat3(	gl_ModelViewMatrixInverseTranspose[0].xyz, 
				gl_ModelViewMatrixInverseTranspose[1].xyz,
				gl_ModelViewMatrixInverseTranspose[2].xyz)*N;
	
	gl_Position = gl_ModelViewProjectionMatrix*V;
}
]]>		
		</program>
		<program name="fp" type="fragment">
<![CDATA[

uniform vec4 fig;
uniform float thresh;
uniform vec4 Ia;
uniform vec4 Ii;
uniform vec3 eyePosition;
uniform vec4 Ke;
uniform vec4 Ka;
uniform vec4 Kd;
uniform vec4 Ks;
uniform float Ns;
uniform vec4 couleur;

varying vec3 N;
varying vec3 P;

//setup for 1 texture
//varying vec2 texcoord0;
//uniform sampler2DRect tex0;

void main (void)
{
	

//	vec4 at = texture2DRect(tex0, texcoord0);
	
	vec3 Nn = normalize(N);
	vec3 dt = Nn;	float eye =  dot(normalize(P),dt);	vec3 t2 = sin(dt.xyz*fig.yzw)+sin(dt.zyx*fig.yzw);	t2 = abs(t2);	float goop = dot(t2,vec3(1.));	goop = goop*0.25;				if (goop <thresh) discard;
	
	//ambient contribution
	vec4 ambient = Ia*Ka;
	
	vec3 lightPosition = vec3(gl_LightSource[0].position);
	
	//diffuse contribution
	vec3 L = normalize(lightPosition - P);
	vec4 diffuse = Kd*Ii*max(dot(Nn, L), 0.);
	
	//calculate specular contribution
	vec3 V = normalize(eyePosition - P);
	vec3 H = normalize(L + V); //average of lighting and view vector)  not true reflection vector
	vec4 specular = Ks*Ii * pow(max(dot(Nn,H), 0.), Ns);
	
	gl_FragColor = (Ke + ambient + diffuse + specular+0.2)*couleur;
}
]]>		
		</program>		
	</language>
</jittershader>
